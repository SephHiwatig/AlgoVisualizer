{"ast":null,"code":"import { PathInfo } from \"./dijkstra.model\";\nimport * as i0 from \"@angular/core\";\nexport let PathService = /*#__PURE__*/(() => {\n  class PathService {\n    constructor() {\n      this.matrix = [];\n      this.start = [0, 0];\n      this.finish = [24, 24];\n      this.pathInfoTable = [];\n      this.GRID_SIZE = 25;\n      this.dijkstraStarted = false;\n      this.astarStarted = false;\n    }\n    generateGrid() {\n      this.matrix = [];\n      this.start = [0, 0];\n      this.finish = [this.GRID_SIZE - 1, this.GRID_SIZE - 1];\n      this.nodeToMove = undefined;\n      this.pathInfoTable = [];\n      const visualContainer = document.querySelector(\".algo-visual\");\n      visualContainer.style.flexDirection = \"column\";\n      // create 10 rows\n      for (let i = 0; i < this.GRID_SIZE; i++) {\n        let row = document.createElement(\"div\");\n        row.classList.add(\"row\");\n        row.draggable = false;\n        let matrixRow = [];\n        // create 10 columns\n        for (let j = 0; j < this.GRID_SIZE; j++) {\n          let col = document.createElement(\"div\");\n          col.setAttribute(\"class\", \"col\");\n          col.setAttribute(\"id\", i + \"-\" + j);\n          col.draggable = false;\n          col.addEventListener(\"drop\", event => {\n            this.drop(event);\n          });\n          col.addEventListener(\"dragover\", event => {\n            this.allowDrop(event);\n          });\n          col.addEventListener(\"mouseenter\", event => {\n            if (event.buttons === 1) {\n              const el = event.target;\n              if (el.childElementCount === 0) {\n                let indeces = el.id.split(\"-\").map(x => parseInt(x));\n                this.matrix[indeces[0]][indeces[1]] = null;\n                el.style.backgroundColor = \"#2b2b2b\";\n                el.classList.add(\"wall\");\n              }\n            }\n          });\n          col.addEventListener(\"mousedown\", event => {\n            const el = event.target;\n            if (el.childElementCount === 0) {\n              let indeces = el.id.split(\"-\").map(x => parseInt(x));\n              this.matrix[indeces[0]][indeces[1]] = null;\n              el.style.backgroundColor = \"#2b2b2b\";\n              el.classList.add(\"wall\");\n            }\n          });\n          if (i === 0 && j === 0) {\n            matrixRow.push(0);\n            let img = document.createElement(\"img\");\n            img.classList.add(\"node\");\n            img.setAttribute(\"src\", \"./assets/imgs/start.png\");\n            img.setAttribute(\"id\", \"start\");\n            img.draggable = true;\n            img.addEventListener(\"dragstart\", event => {\n              this.drag(event);\n            });\n            img.addEventListener(\"mousedown\", event => {\n              event.stopPropagation();\n            });\n            col.appendChild(img);\n          } else {\n            matrixRow.push(1);\n          }\n          if (i === this.GRID_SIZE - 1 && j === this.GRID_SIZE - 1) {\n            let img = document.createElement(\"img\");\n            img.classList.add(\"node\");\n            img.setAttribute(\"src\", \"./assets/imgs/finish.png\");\n            img.setAttribute(\"id\", \"finish\");\n            img.addEventListener(\"dragstart\", event => {\n              this.drag(event);\n            });\n            img.addEventListener(\"mousedown\", event => {\n              event.stopPropagation();\n            });\n            col.appendChild(img);\n          }\n          row.appendChild(col);\n          const vertex = new PathInfo();\n          vertex.vertex = i + \"-\" + j;\n          vertex.distanceFromOrigin = Infinity;\n          vertex.previousVertex = null;\n          this.pathInfoTable.push(vertex);\n        }\n        this.matrix.push(matrixRow);\n        visualContainer.appendChild(row);\n      }\n    }\n    startDijkstra() {\n      if (this.dijkstraStarted) {\n        return;\n      }\n      this.dijkstraStarted = true;\n      let visited = [];\n      // let unvisited = this.matrix.map((row) => {\n      //   return row.filter((col) => col !== null);\n      // });\n      const startVertex = this.start.join(\"-\");\n      this.pathInfoTable.find(x => x.vertex === startVertex).distanceFromOrigin = 0;\n      let dijInterval = setInterval(() => {\n        visited = this.checkVertices(visited, false);\n        let unvisited = this.pathInfoTable.filter(x => x.distanceFromOrigin !== 0 && x.previousVertex !== null && x.distanceFromOrigin !== Infinity && !visited.includes(x.vertex));\n        if (!unvisited || unvisited.length === 0 || visited.includes(this.finish.join(\"-\"))) {\n          clearInterval(dijInterval);\n          visited.forEach(vertex => {\n            document.getElementById(vertex).style.backgroundColor = \"#fff\";\n          });\n          this.showShortestPath();\n        } else {\n          unvisited = unvisited.sort((a, b) => a.distanceFromOrigin - b.distanceFromOrigin);\n          let nextOrigin = unvisited[0].vertex;\n          this.start = nextOrigin.split(\"-\").map(x => parseInt(x));\n          let elId = visited[visited.length - 1];\n          document.getElementById(elId).style.backgroundColor = \"#1ec5fc\";\n        }\n      }, 10);\n    }\n    startAStar() {\n      if (this.astarStarted) {\n        return;\n      }\n      this.astarStarted = true;\n      let visited = [];\n      // let unvisited = this.matrix.map((row) => {\n      //   return row.filter((col) => col !== null);\n      // });\n      const startVertex = this.start.join(\"-\");\n      this.pathInfoTable.find(x => x.vertex === startVertex).distanceFromOrigin = 0;\n      let dijInterval = setInterval(() => {\n        visited = this.checkVertices(visited, true);\n        let unvisited = this.pathInfoTable.filter(x => x.distanceFromOrigin !== 0 && x.previousVertex !== null && x.distanceFromOrigin !== Infinity && !visited.includes(x.vertex));\n        if (!unvisited || unvisited.length === 0 || visited.includes(this.finish.join(\"-\"))) {\n          clearInterval(dijInterval);\n          visited.forEach(vertex => {\n            document.getElementById(vertex).style.backgroundColor = \"#fff\";\n          });\n          this.showShortestPath();\n        } else {\n          unvisited = unvisited.sort((a, b) => a.distanceFromOrigin - b.distanceFromOrigin);\n          let nextOrigin = unvisited[0].vertex;\n          this.start = nextOrigin.split(\"-\").map(x => parseInt(x));\n          let elId = visited[visited.length - 1];\n          document.getElementById(elId).style.backgroundColor = \"#1ec5fc\";\n        }\n      }, 10);\n    }\n    showShortestPath() {\n      let path = [];\n      let step = this.pathInfoTable.find(x => x.vertex === this.finish.join(\"-\"));\n      path.push(step.vertex);\n      while (step.previousVertex) {\n        step = this.pathInfoTable.find(x => x.vertex === step.previousVertex);\n        path.push(step.vertex);\n      }\n      path.pop();\n      let showPathInterval = setInterval(() => {\n        if (path.length > 0) {\n          let vertex = path.pop();\n          document.getElementById(vertex).style.backgroundColor = \"#1ec5fc\";\n        } else {\n          clearInterval(showPathInterval);\n          this.showReset();\n        }\n      }, 100);\n    }\n    checkVertices(visited, astar) {\n      // Top\n      if (this.start[0] - 1 >= 0) {\n        let top = [this.start[0] - 1, this.start[1]];\n        if (this.matrix[top[0]][top[1]] !== null) {\n          let previous = [top[0] + 1, top[1]];\n          let distance = this.calcDistance(previous);\n          if (astar) {\n            distance += this.calcEuclideanDistance(top, this.finish);\n          }\n          let pathToUpdate = this.pathInfoTable.find(x => x.vertex === top.join(\"-\"));\n          if (distance < pathToUpdate.distanceFromOrigin) {\n            pathToUpdate.distanceFromOrigin = distance;\n            pathToUpdate.previousVertex = previous.join(\"-\");\n          }\n        }\n      }\n      // Right\n      if (this.start[1] + 1 <= this.GRID_SIZE - 1) {\n        let right = [this.start[0], this.start[1] + 1];\n        if (this.matrix[right[0]][right[1]] !== null) {\n          let previous = [right[0], right[1] - 1];\n          let distance = this.calcDistance(previous);\n          if (astar) {\n            distance += this.calcEuclideanDistance(right, this.finish);\n          }\n          let pathToUpdate = this.pathInfoTable.find(x => x.vertex === right.join(\"-\"));\n          if (distance < pathToUpdate.distanceFromOrigin) {\n            pathToUpdate.distanceFromOrigin = distance;\n            pathToUpdate.previousVertex = previous.join(\"-\");\n          }\n        }\n      }\n      // Bottom\n      if (this.start[0] + 1 <= this.GRID_SIZE - 1) {\n        let bottom = [this.start[0] + 1, this.start[1]];\n        if (this.matrix[bottom[0]][bottom[1]] !== null) {\n          let previous = [bottom[0] - 1, bottom[1]];\n          let distance = this.calcDistance(previous);\n          if (astar) {\n            distance += this.calcEuclideanDistance(bottom, this.finish);\n          }\n          let pathToUpdate = this.pathInfoTable.find(x => x.vertex === bottom.join(\"-\"));\n          if (distance < pathToUpdate.distanceFromOrigin) {\n            pathToUpdate.distanceFromOrigin = distance;\n            pathToUpdate.previousVertex = previous.join(\"-\");\n          }\n        }\n      }\n      // Left\n      if (this.start[1] - 1 >= 0) {\n        let left = [this.start[0], this.start[1] - 1];\n        if (this.matrix[left[0]][left[1]] !== null) {\n          let previous = [left[0], left[1] + 1];\n          let distance = this.calcDistance(previous);\n          if (astar) {\n            distance += this.calcEuclideanDistance(left, this.finish);\n          }\n          let pathToUpdate = this.pathInfoTable.find(x => x.vertex === left.join(\"-\"));\n          if (distance < pathToUpdate.distanceFromOrigin) {\n            pathToUpdate.distanceFromOrigin = distance;\n            pathToUpdate.previousVertex = previous.join(\"-\");\n          }\n        }\n      }\n      visited.push(this.start.join(\"-\"));\n      return visited;\n    }\n    calcDistance(previous) {\n      let distance = 0;\n      while (previous && previous.length > 0) {\n        distance += 1;\n        let previousString = previous.join(\"-\");\n        let previousVertex = this.pathInfoTable.find(x => x.vertex === previousString);\n        if (previousVertex.previousVertex) {\n          previous = previousVertex.previousVertex.split(\"-\").map(x => parseInt(x));\n        } else {\n          previous = undefined;\n        }\n      }\n      return distance;\n    }\n    calcEuclideanDistance(vertex1, vertex2) {\n      return Math.abs(vertex1[0] - vertex2[0]) + Math.abs(vertex1[1] - vertex2[1]);\n    }\n    allowDrop(ev) {\n      ev.preventDefault();\n    }\n    drag(ev) {\n      let el = ev.target;\n      this.nodeToMove = el.id;\n      ev.dataTransfer.setData(\"text\", ev.target.id);\n    }\n    drop(ev) {\n      let el = ev.target;\n      ev.preventDefault();\n      if (!el.classList.contains(\"wall\") && el.id !== \"start\" && el.id !== \"finish\") {\n        if (this.nodeToMove === \"start\") {\n          this.matrix[this.start[0]][this.start[1]] = 1;\n          this.start = el.id.split(\"-\").map(x => parseInt(x));\n          this.matrix[this.start[0]][this.start[1]] = 0;\n        } else if (this.nodeToMove === \"finish\") {\n          this.finish = el.id.split(\"-\").map(x => parseInt(x));\n        }\n        this.nodeToMove = undefined;\n        let data = ev.dataTransfer.getData(\"text\");\n        if (data && data.length > 0 && data !== \"\") {\n          let img = document.getElementById(data);\n          ev.target.appendChild(img);\n        }\n      }\n    }\n    showReset() {\n      const visualContainer = document.querySelector(\".algo-visual\");\n      let resetContainer = document.createElement(\"div\");\n      resetContainer.style.margin = \"auto\";\n      resetContainer.style.top = \"35%\";\n      resetContainer.style.left = \"45%\";\n      resetContainer.style.position = \"absolute\";\n      resetContainer.style.zIndex = \"999\";\n      resetContainer.style.background = \"#fff\";\n      resetContainer.style.border = \"1px solid grey\";\n      resetContainer.style.padding = \"10px\";\n      resetContainer.style.borderRadius = \"4px\";\n      resetContainer.style.textAlign = \"center\";\n      resetContainer.style.minWidth = \"100px\";\n      let found = document.createElement(\"p\");\n      found.innerHTML = \"Reset\";\n      let resetBtn = document.createElement(\"button\");\n      resetBtn.innerHTML = \"Reset\";\n      resetBtn.style.borderRadius = \"4px\";\n      resetBtn.style.padding = \"5px\";\n      resetBtn.style.background = \"#1fa638\";\n      resetBtn.style.border = \"none\";\n      resetBtn.style.cursor = \"pointer\";\n      resetBtn.addEventListener(\"click\", () => {\n        window.location.reload();\n      });\n      resetContainer.appendChild(found);\n      resetContainer.appendChild(resetBtn);\n      visualContainer.appendChild(resetContainer);\n    }\n    static #_ = this.ɵfac = function PathService_Factory(t) {\n      return new (t || PathService)();\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: PathService,\n      factory: PathService.ɵfac,\n      providedIn: \"root\"\n    });\n  }\n  return PathService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}